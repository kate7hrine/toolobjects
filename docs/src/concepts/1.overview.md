It's a short overview, the details will be disclosured in other files.

The common class in app is an Object (or plugin, script). Basically, it's a pydantic model. It may be any entity that can contain any data or methods, can be serialized into and from JSON. Every Object has a name, that assigned from path relatively cwd. Object can has [fields](https://docs.pydantic.dev/latest/concepts/fields/). You can create a connection between two objects instances by Link. Also you can reference a link into fields. The class can have links to other classes - it is a submodules. Object can have hook functions, settings, requirements etc.

Object can be runned, but if it is an Executable. Executable has entry point (contain some running logic), validation, but also can be used as Object. Executable can return anything ([Act](../objects/App.Objects.Act.md)), return only objects ([Extractor](../objects/App.Objects.Extractor.md)) or be representation of running program ([View](../objects/App.Objects.View.md), [Console](../objects/App.Console.Console.md)).

To know in advance, what modules are exist in app, they are loaded by [Namespaces](../objects/App.Objects.Index.Namespace.md). You can add custom namespaces. 

To store settings, there is [Config](../objects/App.Config.Config.md). To log messages, there is [Logger](../objects/App.Logger.Logger.md). To create restrictions of usage, there is AuthLayer.

In runtime object can exist locally, but it must be saved somewhere. So, object can be flushed into DB and has `uuid`. Link also can has `uuid`. DBs are represented by [Storage](../objects/App.Storage.Storage.md) and [StorageItems](../objects/App.Storage.Storage.Item.StorageItem.md). Object can reference to files ([StorageUnits](../objects/App.Storage.StorageUnit.md)).
